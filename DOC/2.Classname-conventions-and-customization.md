Classname conventions and customization
===

The class responsible for loading model services and constructing classnames is
[`EntityServiceAccessor`](../src/EntityServiceAccessor.php).

In default, this class supposes following naming of model services. To change it, extend EntityServiceAccessor
and override touched methods:

#### Entity

Entity classname is calculated from Facade classname. If Facade classname is `Any\Namespace\ProductFacade`, as an Entity
classname is assumed `Any\Namespace\Product` (the word "Facade" is cut off).

To change this behavior, override method `getEntityClass()`.

*OR* you can exploit Facade's property `$entityClass` to define Entity classname there:

```php
class ProductFacade extends \LazyDataMapper\Facade
{
	protected $entityClass = 'Product';
}
```

#### Mapper

Mapper classname is calculated from Entity classname - this way: `Any\Namespace\Product` → `Any\Namespace\ProductMapper`.

To change this calculating, override method `getMapperClass()`.

To change the way of creating new Mapper (e.g. to give dependencies, let load Mapper by your framework,
etc. - see [example](#example) below) override method `createMapper()`.

#### ParamMap and Checker

ParamMap and Checker classnames (see [Checker DOC](8.Checker.md)) are calculated from Entity classname similarly:

- `Any\Namespace\Product` → `Any\Namespace\ProductParamMap`
- `Any\Namespace\Product` → `Any\Namespace\ProductChecker`

Change it by overriding methods `getParamMap()` and `getChecker()`.

#### EntityCollection

EntityCollection classname (see [EntityCollection DOC](6.EntityCollection.md)) is calculated from Entity classname by adding
"s" (or "es" following "y" changed to "i") at the end.

- `Any\Namespace\Product` → `Any\Namespace\Products`
- `Any\Namespace\Story` → `Any\Namespace\Stories`.

To do this by your own rules, override method `getEntityCollectionClass()`.

*Default pluralization is actually very simple and incomplete, for much better results let inspire by
[PHP class for pluralizing english words](https://gist.github.com/VladaHejda/8775965).*

*OR*, as like as in Entity classname case, you can add EntityCollection classname into Facade's property `$entityClass`,
as second member of array:

```php
class ProductFacade extends \LazyDataMapper\Facade
{
	protected $entityClass = [
		'Product',
		'Products'
	];
}
```

### Example

In this example, we will create classes with little changed classname conventions:

- `\Product` as the Entity
- `\Product\Facade` (default expects just `\ProductFacade`)
- `\Product\ParamMap`
- `\Product\Mapper`

Let's do it:

```php
class Product extends \LazyDataMapper\Entity
{
}
```

```php
namespace Product;

class Facade extends \LazyDataMapper\Facade
{
}
```

```php
namespace Product;

class ParamMap extends \LazyDataMapper\ParamMap
{
	protected function loadMap()
	{
		return [ 'name', 'price', 'count', ];
	}
}
```

In our example, Mapper needs [PDO](http://www.php.net/manual/en/intro.pdo.php):

```php
namespace Product;

class Mapper implements \LazyDataMapper\IMapper
{
	/** @var \PDO */
	private $pdo;

	public function __construct(\PDO $pdo)
	{
		$this->pdo = $pdo;
	}

	// ...
}
```

So we must override method `createMapper()` in EntityServiceAccessor to maintain dependency injection and inject
PDO into Mapper. Then we must little adapt classname calculators (`getEntityClass()`, `getParamMapClass()`, ...)
to solve changed classname conventions too:

```php
class MyEntityServiceAccessor extends \LazyDataMapper\EntityServiceAccessor
{
	/** @var \PDO */
	protected $pdo;

	public function __construct(\PDO $pdo)
	{
		$this->pdo = $pdo;
	}

	public function getEntityClass(\LazyDataMapper\Facade $facade)
	{
		return substr(get_class($facade), 0, -7);
	}

	protected function getParamMapClass($entityClass)
	{
		return $entityClass . '\ParamMap';
	}

	protected function getMapperClass($entityClass)
	{
		return $entityClass . '\Mapper';
	}

	protected function getCheckerClass($entityClass)
	{
		return $entityClass . '\Checker';
	}

	protected function createMapper($mapper)
	{
		return new $mapper($this->pdo);
	}
}
```

Now we just [init](1.Installation.md#init-lazydatamapper) **MyEntityServiceAccessor** instead of default
`LazyDataMapper\EntityServiceAccessor`.

*If you will completely rewrite the EntityServiceAccessor class, consider writing completely new class, that implements
[`IEntityServiceAccessor`](../src/interfaces/IEntityServiceAccessor.php) instead of inheriting already implemented
[`EntityServiceAccessor`](../src/EntityServiceAccessor.php).*


**[← Installation](1.Installation.md)
| [Contents](../readme.md#documentation)
| [Entity reading →](3.Entity-reading.md)**
